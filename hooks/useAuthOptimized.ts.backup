import { useState, useEffect, useCallback, useMemo } from 'react';
import { onAuthStateChanged, User, signInWithPopup, GoogleAuthProvider, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updateProfile } from 'firebase/auth';
import { useRouter, usePathname } from 'next/navigation';
import { auth } from '@/lib/firebase';
import { usePerformanceMonitor } from '@/hooks/usePerformanceMonitor';
import { doc, setDoc, getDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import toast from 'react-hot-toast';

interface AuthState {
  user: User | null;
  loading: boolean;
  error: string | null;
}

interface AuthActions {
  signInWithGoogle: () => Promise<void>;
  signInWithEmail: (email: string, password: string) => Promise<void>;
  signUpWithEmail: (email: string, password: string, displayName?: string) => Promise<void>;
  signOut: () => Promise<void>;
  updateUserProfile: (updates: { displayName?: string; photoURL?: string }) => Promise<void>;
  clearError: () => void;
}

interface UseAuthOptimizedReturn extends AuthState, AuthActions {
  // Computed values
  isAuthenticated: boolean;
  isGuest: boolean;
  userProfile: {
    displayName: string | null;
    email: string | null;
    photoURL: string | null;
    uid: string | null;
  } | null;
  
  // Utilities
  checkAuthStatus: () => Promise<boolean>;
  saveUserToFirestore: (userData: any) => Promise<void>;
  getUserFromFirestore: (uid: string) => Promise<any>;
}

export function useAuthOptimized(): UseAuthOptimizedReturn {
  const { trackApiCall } = usePerformanceMonitor('Auth');
  
  // State
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Router and pathname
  const router = useRouter();
  const pathname = usePathname();

  // Memoized computed values
  const isAuthenticated = useMemo(() => {
    return user !== null;
  }, [user]);

  const isGuest = useMemo(() => {
    return user === null && !loading;
  }, [user, loading]);

  const userProfile = useMemo(() => {
    if (!user) return null;
    
    return {
      displayName: user.displayName,
      email: user.email,
      photoURL: user.photoURL,
      uid: user.uid,
    };
  }, [user]);

  // Memoized handlers
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const checkAuthStatus = useCallback(async (): Promise<boolean> => {
    const startTime = performance.now();
    
    return new Promise((resolve) => {
      const unsubscribe = onAuthStateChanged(auth, (authUser) => {
        setUser(authUser);
        setLoading(false);
        trackApiCall('/api/checkAuthStatus', performance.now() - startTime, true);
        unsubscribe();
        resolve(!!authUser);
      });
    });
  }, [trackApiCall]);

  const saveUserToFirestore = useCallback(async (userData: any): Promise<void> => {
    const startTime = performance.now();
    
    try {
      if (!userData.uid) {
        throw new Error('User UID is required');
      }
      
      await setDoc(doc(db, 'users', userData.uid), {
        ...userData,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });
      
      trackApiCall('/api/saveUserToFirestore', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error saving user to Firestore:', error);
      trackApiCall('/api/saveUserToFirestore', performance.now() - startTime, false);
      throw error;
    }
  }, [trackApiCall]);

  const getUserFromFirestore = useCallback(async (uid: string): Promise<any> => {
    const startTime = performance.now();
    
    try {
      const userDoc = await getDoc(doc(db, 'users', uid));
      
      if (userDoc.exists()) {
        trackApiCall('/api/getUserFromFirestore', performance.now() - startTime, true);
        return userDoc.data();
      } else {
        trackApiCall('/api/getUserFromFirestore', performance.now() - startTime, false);
        return null;
      }
    } catch (error) {
      console.error('Error getting user from Firestore:', error);
      trackApiCall('/api/getUserFromFirestore', performance.now() - startTime, false);
      throw error;
    }
  }, [trackApiCall]);

  const signInWithGoogle = useCallback(async (): Promise<void> => {
    const startTime = performance.now();
    setError(null);
    
    try {
      const provider = new GoogleAuthProvider();
      provider.addScope('https://www.googleapis.com/auth/gmail.readonly');
      provider.addScope('https://www.googleapis.com/auth/calendar');
      
      const result = await signInWithPopup(auth, provider);
      
      // Save user data to localStorage for future reference
      if (result.user) {
        localStorage.setItem('lastSignInMethod', 'google');
        localStorage.setItem('lastGoogleEmail', result.user.email || '');
        localStorage.setItem('lastGoogleName', result.user.displayName || '');
        localStorage.setItem('lastGooglePicture', result.user.photoURL || '');
        localStorage.setItem('lastGoogleUserId', result.user.uid);
        
        // Save to Firestore
        await saveUserToFirestore({
          uid: result.user.uid,
          email: result.user.email,
          displayName: result.user.displayName,
          photoURL: result.user.photoURL,
          provider: 'google',
        });
      }
      
      trackApiCall('/api/signInWithGoogle', performance.now() - startTime, true);
      toast.success('Successfully signed in with Google!');
    } catch (error: any) {
      console.error('Google sign-in error:', error);
      setError(error.message || 'Failed to sign in with Google');
      trackApiCall('/api/signInWithGoogle', performance.now() - startTime, false);
      toast.error('Failed to sign in with Google');
    }
  }, [saveUserToFirestore, trackApiCall]);

  const signInWithEmail = useCallback(async (email: string, password: string): Promise<void> => {
    const startTime = performance.now();
    setError(null);
    
    try {
      const result = await signInWithEmailAndPassword(auth, email, password);
      
      // Save user data to localStorage
      localStorage.setItem('lastSignInMethod', 'email');
      localStorage.setItem('lastGoogleEmail', result.user.email || '');
      localStorage.setItem('lastGoogleName', result.user.displayName || '');
      localStorage.setItem('lastGooglePicture', result.user.photoURL || '');
      localStorage.setItem('lastGoogleUserId', result.user.uid);
      
      trackApiCall('/api/signInWithEmail', performance.now() - startTime, true);
      toast.success('Successfully signed in!');
    } catch (error: any) {
      console.error('Email sign-in error:', error);
      setError(error.message || 'Failed to sign in');
      trackApiCall('/api/signInWithEmail', performance.now() - startTime, false);
      toast.error('Failed to sign in');
    }
  }, [trackApiCall]);

  const signUpWithEmail = useCallback(async (email: string, password: string, displayName?: string): Promise<void> => {
    const startTime = performance.now();
    setError(null);
    
    try {
      const result = await createUserWithEmailAndPassword(auth, email, password);
      
      // Update profile if display name provided
      if (displayName && result.user) {
        await updateProfile(result.user, { displayName });
      }
      
      // Save user data to localStorage
      localStorage.setItem('lastSignInMethod', 'email');
      localStorage.setItem('lastGoogleEmail', result.user.email || '');
      localStorage.setItem('lastGoogleName', result.user.displayName || '');
      localStorage.setItem('lastGooglePicture', result.user.photoURL || '');
      localStorage.setItem('lastGoogleUserId', result.user.uid);
      
      // Save to Firestore
      await saveUserToFirestore({
        uid: result.user.uid,
        email: result.user.email,
        displayName: result.user.displayName,
        photoURL: result.user.photoURL,
        provider: 'email',
      });
      
      trackApiCall('/api/signUpWithEmail', performance.now() - startTime, true);
      toast.success('Account created successfully!');
    } catch (error: any) {
      console.error('Email sign-up error:', error);
      setError(error.message || 'Failed to create account');
      trackApiCall('/api/signUpWithEmail', performance.now() - startTime, false);
      toast.error('Failed to create account');
    }
  }, [saveUserToFirestore, trackApiCall]);

  const signOutUser = useCallback(async (): Promise<void> => {
    const startTime = performance.now();
    
    try {
      await signOut(auth);
      
      // Clear localStorage
      localStorage.removeItem('lastSignInMethod');
      localStorage.removeItem('lastGoogleEmail');
      localStorage.removeItem('lastGoogleName');
      localStorage.removeItem('lastGooglePicture');
      localStorage.removeItem('lastGoogleUserId');
      
      trackApiCall('/api/signOut', performance.now() - startTime, true);
      toast.success('Successfully signed out!');
    } catch (error: any) {
      console.error('Sign-out error:', error);
      setError(error.message || 'Failed to sign out');
      trackApiCall('/api/signOut', performance.now() - startTime, false);
      toast.error('Failed to sign out');
    }
  }, [trackApiCall]);

  const updateUserProfile = useCallback(async (updates: { displayName?: string; photoURL?: string }): Promise<void> => {
    const startTime = performance.now();
    
    try {
      if (!user) {
        throw new Error('No user signed in');
      }
      
      await updateProfile(user, updates);
      
      // Update localStorage if display name changed
      if (updates.displayName) {
        localStorage.setItem('lastGoogleName', updates.displayName);
      }
      
      trackApiCall('/api/updateUserProfile', performance.now() - startTime, true);
      toast.success('Profile updated successfully!');
    } catch (error: any) {
      console.error('Profile update error:', error);
      setError(error.message || 'Failed to update profile');
      trackApiCall('/api/updateUserProfile', performance.now() - startTime, false);
      toast.error('Failed to update profile');
    }
  }, [user, trackApiCall]);

  // Auth state listener
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (authUser) => {
      setUser(authUser);
      setLoading(false);
      
      // Only redirect to login if not already on /login or /signup
      if (!authUser && pathname !== '/login' && pathname !== '/signup') {
        router.push('/login');
      }
    });

    return () => unsubscribe();
  }, [pathname, router]);

  return {
    // State
    user,
    loading,
    error,
    
    // Computed values
    isAuthenticated,
    isGuest,
    userProfile,
    
    // Actions
    signInWithGoogle,
    signInWithEmail,
    signUpWithEmail,
    signOut: signOutUser,
    updateUserProfile,
    clearError,
    
    // Utilities
    checkAuthStatus,
    saveUserToFirestore,
    getUserFromFirestore,
  };
} 