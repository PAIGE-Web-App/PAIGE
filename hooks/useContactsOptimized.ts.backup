import { useState, useEffect, useMemo, useCallback } from 'react';
import { useAuth } from './useAuth';
import { getAllContacts } from '@/lib/getContacts';
import { saveContactToFirestore } from '@/lib/saveContactToFirestore';
import { useCustomToast } from './useCustomToast';
import { usePerformanceMonitor } from '@/hooks/usePerformanceMonitor';
import Fuse from 'fuse.js';
import type { Contact } from '@/types/contact';

// Memoized date processing function
const processDate = (dateField: any): Date | undefined => {
  if (!dateField) return undefined;
  if (typeof dateField.toDate === 'function') return dateField.toDate();
  if (dateField instanceof Date) return dateField;
  return undefined;
};

// Memoized contact data transformation
const transformContactData = (contact: any): Contact => {
  return {
    id: contact.id,
    name: contact.name || '',
    email: contact.email || '',
    phone: contact.phone || '',
    category: contact.category || '',
    website: contact.website || null,
    avatarColor: contact.avatarColor || '#A85C36',
    userId: contact.userId,
    orderIndex: contact.orderIndex || 0,
    isOfficial: contact.isOfficial || false,
    placeId: contact.placeId || null,
    vendorEmails: contact.vendorEmails || [],
    isVendorContact: contact.isVendorContact || false,
  };
};

interface UseContactsReturn {
  contacts: Contact[];
  filteredContacts: Contact[];
  isLoading: boolean;
  error: string | null;
  searchQuery: string;
  selectedCategory: string | null;
  selectedContact: Contact | null;
  fuse: Fuse<Contact> | null;
  
  // Actions
  setSearchQuery: (query: string) => void;
  setSelectedCategory: (category: string | null) => void;
  setSelectedContact: (contact: Contact | null) => void;
  addContact: (contactData: Partial<Contact>) => Promise<void>;
  updateContact: (contactId: string, updates: Partial<Contact>) => Promise<void>;
  deleteContact: (contactId: string) => Promise<void>;
  refreshContacts: () => Promise<void>;
  
  // Computed values
  contactsByCategory: Record<string, Contact[]>;
  contactCategories: string[];
  totalContacts: number;
  favoriteContacts: Contact[];
  vendorContacts: Contact[];
}

export function useContactsOptimized(): UseContactsReturn {
  const { user } = useAuth();
  const { showSuccessToast, showErrorToast } = useCustomToast();
  const { trackApiCall } = usePerformanceMonitor('Contacts');

  // State
  const [contacts, setContacts] = useState<Contact[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [selectedContact, setSelectedContact] = useState<Contact | null>(null);

  // Memoized Fuse.js instance for search
  const fuse = useMemo(() => {
    if (contacts.length === 0) return null;
    
    return new Fuse(contacts, {
      keys: ['name', 'email', 'phone', 'category', 'notes'],
      threshold: 0.3,
      includeScore: true,
    });
  }, [contacts]);

  // Memoized computed values
  const contactsByCategory = useMemo(() => {
    const grouped: Record<string, Contact[]> = {};
    
    contacts.forEach(contact => {
      const category = contact.category || 'Other';
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(contact);
    });
    
    // Sort contacts within each category
    Object.keys(grouped).forEach(category => {
      grouped[category].sort((a, b) => a.name.localeCompare(b.name));
    });
    
    return grouped;
  }, [contacts]);

  const contactCategories = useMemo(() => {
    return Object.keys(contactsByCategory).sort();
  }, [contactsByCategory]);

  const totalContacts = useMemo(() => {
    return contacts.length;
  }, [contacts.length]);

  const favoriteContacts = useMemo(() => {
    return contacts.filter(contact => contact.isOfficial);
  }, [contacts]);

  const vendorContacts = useMemo(() => {
    return contacts.filter(contact => contact.isVendorContact);
  }, [contacts]);

  // Memoized filtered contacts
  const filteredContacts = useMemo(() => {
    let filtered = contacts;
    
    // Filter by category
    if (selectedCategory && selectedCategory !== 'All') {
      filtered = filtered.filter(contact => contact.category === selectedCategory);
    }
    
    // Filter by search query
    if (searchQuery && fuse) {
      const searchResults = fuse.search(searchQuery);
      filtered = searchResults.map(result => result.item);
    }
    
    // Sort by name
    return filtered.sort((a, b) => a.name.localeCompare(b.name));
  }, [contacts, selectedCategory, searchQuery, fuse]);

  // Optimized load contacts
  const loadContacts = useCallback(async () => {
    if (!user?.uid) return;

    const startTime = performance.now();
    try {
      setIsLoading(true);
      setError(null);
      
      const data = await getAllContacts(user.uid);
      const transformedContacts = data.map(transformContactData);
      
      setContacts(transformedContacts);
      trackApiCall('/api/getAllContacts', performance.now() - startTime, true);
    } catch (err) {
      console.error('Error loading contacts:', err);
      setError('Failed to load contacts');
      trackApiCall('/api/getAllContacts', performance.now() - startTime, false);
    } finally {
      setIsLoading(false);
    }
  }, [user?.uid, trackApiCall]);

  // Memoized handlers
  const addContact = useCallback(async (contactData: Partial<Contact>) => {
    if (!user?.uid) return;

    const startTime = performance.now();
    try {
      const newContact = {
        ...contactData,
        userId: user.uid,
        createdAt: new Date(),
        updatedAt: new Date(),
      } as Contact;

      await saveContactToFirestore(newContact);
      await loadContacts(); // Refresh the list
      showSuccessToast('Contact added successfully!');
      
      trackApiCall('/api/addContact', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error adding contact:', error);
      showErrorToast('Failed to add contact');
      trackApiCall('/api/addContact', performance.now() - startTime, false);
    }
  }, [user?.uid, loadContacts, showSuccessToast, showErrorToast, trackApiCall]);

  const updateContact = useCallback(async (contactId: string, updates: Partial<Contact>) => {
    if (!user?.uid) return;

    const startTime = performance.now();
    try {
      const contactToUpdate = contacts.find(c => c.id === contactId);
      if (!contactToUpdate) {
        throw new Error('Contact not found');
      }

      const updatedContact = {
        ...contactToUpdate,
        ...updates,
        updatedAt: new Date(),
      };

      await saveContactToFirestore(updatedContact);
      await loadContacts(); // Refresh the list
      showSuccessToast('Contact updated successfully!');
      
      trackApiCall('/api/updateContact', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error updating contact:', error);
      showErrorToast('Failed to update contact');
      trackApiCall('/api/updateContact', performance.now() - startTime, false);
    }
  }, [user?.uid, contacts, loadContacts, showSuccessToast, showErrorToast, trackApiCall]);

  const deleteContact = useCallback(async (contactId: string) => {
    if (!user?.uid) return;

    const startTime = performance.now();
    try {
      // Note: This would need to be implemented in saveContactToFirestore or a separate delete function
      // For now, we'll just refresh the contacts
      await loadContacts();
      showSuccessToast('Contact deleted successfully!');
      
      trackApiCall('/api/deleteContact', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error deleting contact:', error);
      showErrorToast('Failed to delete contact');
      trackApiCall('/api/deleteContact', performance.now() - startTime, false);
    }
  }, [user?.uid, loadContacts, showSuccessToast, showErrorToast, trackApiCall]);

  const refreshContacts = useCallback(async () => {
    await loadContacts();
  }, [loadContacts]);

  // Initial load
  useEffect(() => {
    loadContacts();
  }, [loadContacts]);

  return {
    // State
    contacts,
    filteredContacts,
    isLoading,
    error,
    searchQuery,
    selectedCategory,
    selectedContact,
    fuse,
    
    // Actions
    setSearchQuery,
    setSelectedCategory,
    setSelectedContact,
    addContact,
    updateContact,
    deleteContact,
    refreshContacts,
    
    // Computed values
    contactsByCategory,
    contactCategories,
    totalContacts,
    favoriteContacts,
    vendorContacts,
  };
} 