import { useState, useEffect, useMemo, useCallback } from 'react';
import { db, getUserCollectionRef } from '@/lib/firebase';
import { collection, query, where, orderBy, onSnapshot, addDoc, doc, setDoc, updateDoc, deleteDoc, writeBatch, getDocs, getDoc, limit } from 'firebase/firestore';
import { getAllCategories, saveCategoryIfNew } from '@/lib/firebaseCategories';
import Fuse from 'fuse.js';
import { useCustomToast } from './useCustomToast';
import { useAuth } from './useAuth';
import { usePerformanceMonitor } from '@/hooks/usePerformanceMonitor';
import type { TodoItem, TodoList } from '@/types/todo';
import { sendTodoUpdateNotification } from '@/utils/todoNotifications';

// Utility functions
function removeUndefinedFields<T extends object>(obj: T): Partial<T> {
  return Object.fromEntries(
    Object.entries(obj).filter(([_, v]) => v !== undefined)
  ) as Partial<T>;
}

function parseLocalDateTime(input: string): Date {
  if (typeof input !== 'string') return new Date(NaN);
  const [datePart, timePart] = input.split('T');
  const [year, month, day] = datePart.split('-').map(Number);
  const [hour = 17, minute = 0] = (timePart ? timePart.split(':').map(Number) : [17, 0]);
  // Always create a local date
  return new Date(year, month - 1, day, hour, minute, 0, 0);
}

function forceLocalMidnight(date: Date): Date {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}

const isValidDateInput = (str: any) => {
  if (!str) return false;
  const date = new Date(str);
  return date instanceof Date && !isNaN(date.getTime());
};

// Memoized date processing function
const processDate = (dateField: any): Date | undefined => {
  if (!dateField) return undefined;
  if (typeof dateField.toDate === 'function') return dateField.toDate();
  if (dateField instanceof Date) return dateField;
  return undefined;
};

// Memoized todo item data transformation
const transformTodoItemData = (doc: any): TodoItem => {
  const data = doc.data();
  return {
    id: doc.id,
    listId: data.listId,
    name: data.name,
    isCompleted: data.isCompleted || false,
    orderIndex: data.orderIndex || 0,
    createdAt: processDate(data.createdAt) || new Date(),
    userId: data.userId,
    category: data.category || '',
    note: data.note || '',
    deadline: processDate(data.deadline),
    startDate: processDate(data.startDate),
    endDate: processDate(data.endDate),
    assignedTo: data.assignedTo || null,
    assignedBy: data.assignedBy || null,
    assignedAt: processDate(data.assignedAt),
    notificationRead: data.notificationRead || false,
  };
};

export function useTodoItemsOptimized(selectedList: TodoList | null) {
  const { user } = useAuth();
  const { showSuccessToast, showErrorToast } = useCustomToast();
  const { trackApiCall } = usePerformanceMonitor('TodoItems');

  // State for todo items
  const [allTodoItems, setAllTodoItems] = useState<TodoItem[]>([]);
  const [todoItems, setTodoItems] = useState<TodoItem[]>([]);
  const [newTaskName, setNewTaskName] = useState('');
  const [justMovedItemId, setJustMovedItemId] = useState<string | null>(null);

  // State for categories
  const [allCategories, setAllCategories] = useState<string[]>([]);

  // State for task counts
  const [listTaskCounts, setListTaskCounts] = useState<Map<string, number>>(new Map());

  // State for move task modal
  const [showMoveTaskModal, setShowMoveTaskModal] = useState(false);
  const [taskToMove, setTaskToMove] = useState<TodoItem | null>(null);

  // State for selected task in side card
  const [selectedTaskForSideCard, setSelectedTaskForSideCard] = useState<any | null>(null);
  const [showTaskDetailCard, setShowTaskDetailCard] = useState(false);

  // State for add todo
  const [showAddTodoCard, setShowAddTodoCard] = useState(false);
  const [newTodoName, setNewTodoName] = useState('');
  const [newTodoListId, setNewTodoListId] = useState<string | null>(null);
  const [isAdding, setIsAdding] = useState(false);
  const [newTodoNote, setNewTodoNote] = useState('');
  const [newTodoDeadline, setNewTodoDeadline] = useState('');
  const [newTodoCategory, setNewTodoCategory] = useState('');

  // Memoized computed values
  const allCategoriesCombined = useMemo(() => {
    // Categories from the user's collection
    const fromCollection = allCategories;
    // Categories from the current list's tasks
    const fromTasks = todoItems
      .map((item) => item.category)
      .filter((cat): cat is string => !!cat && typeof cat === 'string');
    // Combine and deduplicate
    return Array.from(new Set([...fromCollection, ...fromTasks])).filter(Boolean);
  }, [allCategories, todoItems]);

  const sortedTodoItems = useMemo(() => {
    return [...todoItems].sort((a, b) => {
      // First sort by orderIndex
      if (a.orderIndex !== b.orderIndex) {
        return a.orderIndex - b.orderIndex;
      }
      // Then by creation date
      return a.createdAt.getTime() - b.createdAt.getTime();
    });
  }, [todoItems]);

  const completedItems = useMemo(() => {
    return sortedTodoItems.filter(item => item.isCompleted);
  }, [sortedTodoItems]);

  const incompleteItems = useMemo(() => {
    return sortedTodoItems.filter(item => !item.isCompleted);
  }, [sortedTodoItems]);

  const totalItems = useMemo(() => {
    return todoItems.length;
  }, [todoItems.length]);

  const completedCount = useMemo(() => {
    return completedItems.length;
  }, [completedItems]);

  const incompleteCount = useMemo(() => {
    return incompleteItems.length;
  }, [incompleteItems]);

  useEffect(() => {
    if (justMovedItemId) {
      const timer = setTimeout(() => setJustMovedItemId(null), 1200); // Flash for 1.2s
      return () => clearTimeout(timer);
    }
  }, [justMovedItemId]);

  // Optimized fetch categories with a realtime listener
  useEffect(() => {
    if (user) {
      const categoriesRef = getUserCollectionRef('categories', user.uid);
      const q = query(categoriesRef, orderBy('name', 'asc'), limit(100));

      const unsubscribe = onSnapshot(q, (snapshot) => {
        const categories = snapshot.docs.map(doc => (doc.data() as { name: string }).name);
        setAllCategories(categories);
      }, (error) => {
        console.error('Error fetching categories:', error);
      });

      return () => unsubscribe();
    }
  }, [user]);

  // Optimized fetch todo items with pagination
  useEffect(() => {
    if (!user) return;

    let q;
    if (selectedList) {
      // Fetch items for specific list
      q = query(
        getUserCollectionRef('todoItems', user.uid),
        where('listId', '==', selectedList.id),
        where('userId', '==', user.uid),
        orderBy('orderIndex', 'asc'),
        orderBy('createdAt', 'asc'),
        limit(200) // Limit for better performance
      );
    } else {
      // Fetch all items
      q = query(
        getUserCollectionRef('todoItems', user.uid),
        where('userId', '==', user.uid),
        orderBy('orderIndex', 'asc'),
        orderBy('createdAt', 'asc'),
        limit(500) // Higher limit for all items view
      );
    }

    const unsubscribeItems = onSnapshot(q, (snapshot) => {
      const items: TodoItem[] = snapshot.docs.map(transformTodoItemData);
      
      if (selectedList) {
        setTodoItems(items);
      } else {
        setAllTodoItems(items);
        setTodoItems(items);
      }

      // Update task counts
      const counts = new Map<string, number>();
      items.forEach(item => {
        const listId = item.listId;
        counts.set(listId, (counts.get(listId) || 0) + 1);
      });
      setListTaskCounts(counts);
    }, (error) => {
      console.error('Error fetching todo items:', error);
      showErrorToast('Failed to load todo items');
    });

    return () => unsubscribeItems();
  }, [user, selectedList, showErrorToast]);

  // Memoized handlers
  const handleAddTask = useCallback(async () => {
    if (!user || !selectedList || !newTaskName.trim()) return;

    const startTime = performance.now();
    try {
      const newTask = {
        listId: selectedList.id,
        userId: user.uid,
        name: newTaskName.trim(),
        isCompleted: false,
        orderIndex: todoItems.length,
        createdAt: new Date(),
        updatedAt: new Date(),
        category: '',
        note: '',
      };

      await addDoc(getUserCollectionRef('todoItems', user.uid), newTask);
      setNewTaskName('');
      showSuccessToast('Task added successfully!');
      
      trackApiCall('/api/addTodoTask', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error adding task:', error);
      showErrorToast('Failed to add task');
      trackApiCall('/api/addTodoTask', performance.now() - startTime, false);
    }
  }, [user, selectedList, newTaskName, todoItems.length, showSuccessToast, showErrorToast, trackApiCall]);

  const handleToggleTodoCompletion = useCallback(async (todo: TodoItem) => {
    if (!user) return;

    const startTime = performance.now();
    try {
      const todoRef = doc(getUserCollectionRef('todoItems', user.uid), todo.id);
      const newCompletionStatus = !todo.isCompleted;
      
      await updateDoc(todoRef, {
        isCompleted: newCompletionStatus,
        updatedAt: new Date(),
      });

      showSuccessToast(newCompletionStatus ? 'Task completed!' : 'Task marked as incomplete');
      
      trackApiCall('/api/toggleTodoCompletion', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error toggling todo completion:', error);
      showErrorToast('Failed to update task');
      trackApiCall('/api/toggleTodoCompletion', performance.now() - startTime, false);
    }
  }, [user, showSuccessToast, showErrorToast, trackApiCall]);

  const handleUpdateTodoName = useCallback(async (todoId: string, newName: string) => {
    if (!user) return;

    const startTime = performance.now();
    try {
      const todoRef = doc(getUserCollectionRef('todoItems', user.uid), todoId);
      await updateDoc(todoRef, {
        name: newName.trim(),
        updatedAt: new Date(),
      });

      showSuccessToast('Task name updated successfully!');
      
      trackApiCall('/api/updateTodoName', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error updating todo name:', error);
      showErrorToast('Failed to update task name');
      trackApiCall('/api/updateTodoName', performance.now() - startTime, false);
    }
  }, [user, showSuccessToast, showErrorToast, trackApiCall]);

  const handleUpdateTodoCategory = useCallback(async (todoId: string, newCategory: string) => {
    if (!user) return;

    const startTime = performance.now();
    try {
      const todoRef = doc(getUserCollectionRef('todoItems', user.uid), todoId);
      await updateDoc(todoRef, {
        category: newCategory.trim(),
        updatedAt: new Date(),
      });

      // Save category if it's new
      if (newCategory.trim()) {
        await saveCategoryIfNew(newCategory.trim(), user.uid);
      }

      showSuccessToast('Task category updated successfully!');
      
      trackApiCall('/api/updateTodoCategory', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error updating todo category:', error);
      showErrorToast('Failed to update task category');
      trackApiCall('/api/updateTodoCategory', performance.now() - startTime, false);
    }
  }, [user, showSuccessToast, showErrorToast, trackApiCall]);

  const handleDeleteTodoItem = useCallback(async (todoId: string) => {
    if (!user) return;

    const startTime = performance.now();
    try {
      await deleteDoc(doc(getUserCollectionRef('todoItems', user.uid), todoId));
      showSuccessToast('Task deleted successfully!');
      
      trackApiCall('/api/deleteTodoItem', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error deleting todo item:', error);
      showErrorToast('Failed to delete task');
      trackApiCall('/api/deleteTodoItem', performance.now() - startTime, false);
    }
  }, [user, showSuccessToast, showErrorToast, trackApiCall]);

  const handleUpdateTodoDeadline = useCallback(async (todoId: string, deadline?: string | null, endDate?: string | null) => {
    if (!user) return;

    const startTime = performance.now();
    try {
      const todoRef = doc(getUserCollectionRef('todoItems', user.uid), todoId);
      const updateData: any = {
        updatedAt: new Date(),
      };

      if (deadline !== undefined) {
        updateData.deadline = deadline ? parseLocalDateTime(deadline) : null;
      }

      if (endDate !== undefined) {
        updateData.endDate = endDate ? parseLocalDateTime(endDate) : null;
      }

      await updateDoc(todoRef, updateData);
      showSuccessToast('Task deadline updated successfully!');
      
      trackApiCall('/api/updateTodoDeadline', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error updating todo deadline:', error);
      showErrorToast('Failed to update task deadline');
      trackApiCall('/api/updateTodoDeadline', performance.now() - startTime, false);
    }
  }, [user, showSuccessToast, showErrorToast, trackApiCall]);

  const handleUpdateTodoNote = useCallback(async (todoId: string, newNote: string | null) => {
    if (!user) return;

    const startTime = performance.now();
    try {
      const todoRef = doc(getUserCollectionRef('todoItems', user.uid), todoId);
      await updateDoc(todoRef, {
        note: newNote || '',
        updatedAt: new Date(),
      });

      showSuccessToast('Task note updated successfully!');
      
      trackApiCall('/api/updateTodoNote', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error updating todo note:', error);
      showErrorToast('Failed to update task note');
      trackApiCall('/api/updateTodoNote', performance.now() - startTime, false);
    }
  }, [user, showSuccessToast, showErrorToast, trackApiCall]);

  const handleMoveTodoItem = useCallback(async (taskId: string, currentListId: string, targetListId: string) => {
    if (!user) return;

    const startTime = performance.now();
    try {
      const todoRef = doc(getUserCollectionRef('todoItems', user.uid), taskId);
      await updateDoc(todoRef, {
        listId: targetListId,
        updatedAt: new Date(),
      });

      setJustMovedItemId(taskId);
      showSuccessToast('Task moved successfully!');
      
      trackApiCall('/api/moveTodoItem', performance.now() - startTime, true);
    } catch (error) {
      console.error('Error moving todo item:', error);
      showErrorToast('Failed to move task');
      trackApiCall('/api/moveTodoItem', performance.now() - startTime, false);
    }
  }, [user, showSuccessToast, showErrorToast, trackApiCall]);

  const handleMoveTaskModal = useCallback(async (taskId: string, targetListId: string) => {
    const task = todoItems.find(t => t.id === taskId);
    if (task) {
      await handleMoveTodoItem(taskId, task.listId, targetListId);
      setShowMoveTaskModal(false);
      setTaskToMove(null);
    }
  }, [todoItems, handleMoveTodoItem]);

  const handleOpenAddTodo = useCallback((hasLists: boolean = true) => {
    if (hasLists && selectedList) {
      setNewTodoListId(selectedList.id);
    }
    setShowAddTodoCard(true);
  }, [selectedList]);

  const handleCloseAddTodo = useCallback(() => {
    setShowAddTodoCard(false);
    setNewTodoName('');
    setNewTodoListId(null);
    setNewTodoNote('');
    setNewTodoDeadline('');
    setNewTodoCategory('');
    setIsAdding(false);
  }, []);

  return {
    // State
    allTodoItems,
    todoItems: sortedTodoItems,
    newTaskName,
    justMovedItemId,
    allCategories: allCategoriesCombined,
    listTaskCounts,
    showMoveTaskModal,
    taskToMove,
    selectedTaskForSideCard,
    showTaskDetailCard,
    showAddTodoCard,
    newTodoName,
    newTodoListId,
    isAdding,
    newTodoNote,
    newTodoDeadline,
    newTodoCategory,

    // Computed values
    completedItems,
    incompleteItems,
    totalItems,
    completedCount,
    incompleteCount,

    // Setters
    setNewTaskName,
    setShowMoveTaskModal,
    setTaskToMove,
    setSelectedTaskForSideCard,
    setShowTaskDetailCard,
    setShowAddTodoCard,
    setNewTodoName,
    setNewTodoListId,
    setIsAdding,
    setNewTodoNote,
    setNewTodoDeadline,
    setNewTodoCategory,

    // Handlers
    handleAddTask,
    handleToggleTodoCompletion,
    handleUpdateTodoName,
    handleUpdateTodoCategory,
    handleDeleteTodoItem,
    handleUpdateTodoDeadline,
    handleUpdateTodoNote,
    handleMoveTodoItem,
    handleMoveTaskModal,
    handleOpenAddTodo,
    handleCloseAddTodo,
  };
} 