import { useState, useEffect, useCallback, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { doc, updateDoc, getDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { usePerformanceMonitor } from '@/hooks/usePerformanceMonitor';
import { useUserProfileDataOptimized } from './useUserProfileDataOptimized';
import { useImageOptimization } from './useImageOptimization';
import toast from 'react-hot-toast';
import { v4 as uuidv4 } from 'uuid';

interface OnboardingContact {
  id: string;
  name: string;
  email: string | null;
  phone: string | null;
  category: string;
  website: string | null;
  avatarColor: string;
  userId: string;
  orderIndex?: number;
  placeId?: string | null;
  isVendorContact?: boolean;
}

interface OnboardingStep {
  id: number;
  name: string;
  isComplete: boolean;
  isRequired: boolean;
}

interface OnboardingData {
  // Step 1: Basic Info
  userName: string;
  partnerName: string;
  partnerEmail: string;
  plannerName: string;
  plannerEmail: string;
  
  // Step 2: Wedding Details
  weddingDate: string;
  weddingLocation: string;
  weddingLocationUndecided: boolean;
  hasVenue: boolean | null;
  selectedVenueMetadata: any | null;
  selectedPlannerMetadata: any | null;
  
  // Step 3: Vibe & Style
  vibe: string[];
  vibeInputMethod: 'pills' | 'image' | 'pinterest';
  generatedVibes: string[];
  inspirationImage: File | null;
  imagePreview: string | null;
  pinterestLink: string;
  
  // Step 4: Budget & Guests
  maxBudget: number;
  guestCount: number;
  
  // Step 5: Contacts
  contacts: OnboardingContact[];
  selectedCommunicationChannels: string[];
  
  // Meta
  currentStep: number;
  isOnboarded: boolean;
  onboardingCompletedAt: string | null;
}

interface UseOnboardingReturn {
  // State
  onboardingData: OnboardingData;
  currentStep: number;
  isLoading: boolean;
  isSaving: boolean;
  errors: Record<string, string>;
  
  // Computed values
  steps: OnboardingStep[];
  isStepComplete: (stepId: number) => boolean;
  canProceedToNext: (stepId: number) => boolean;
  progressPercentage: number;
  totalSteps: number;
  
  // Actions
  setCurrentStep: (step: number) => void;
  updateField: (field: keyof OnboardingData, value: any) => void;
  updateContact: (contactId: string, updates: Partial<OnboardingContact>) => void;
  addContact: () => void;
  removeContact: (contactId: string) => void;
  
  // Form handlers
  handleNextStep: () => Promise<void>;
  handlePreviousStep: () => void;
  handleSaveStep: (stepData: Partial<OnboardingData>) => Promise<boolean>;
  handleCompleteOnboarding: () => Promise<void>;
  
  // Utilities
  validateStep: (stepId: number) => boolean;
  clearErrors: () => void;
  resetOnboarding: () => void;
}

const DEFAULT_ONBOARDING_DATA: OnboardingData = {
  // Step 1: Basic Info
  userName: '',
  partnerName: '',
  partnerEmail: '',
  plannerName: '',
  plannerEmail: '',
  
  // Step 2: Wedding Details
  weddingDate: '',
  weddingLocation: '',
  weddingLocationUndecided: false,
  hasVenue: null,
  selectedVenueMetadata: null,
  selectedPlannerMetadata: null,
  
  // Step 3: Vibe & Style
  vibe: [],
  vibeInputMethod: 'pills',
  generatedVibes: [],
  inspirationImage: null,
  imagePreview: null,
  pinterestLink: '',
  
  // Step 4: Budget & Guests
  maxBudget: 35000,
  guestCount: 100,
  
  // Step 5: Contacts
  contacts: [],
  selectedCommunicationChannels: [],
  
  // Meta
  currentStep: 1,
  isOnboarded: false,
  onboardingCompletedAt: null,
};

const ONBOARDING_STEPS = [
  { id: 1, name: 'Basic Info', isRequired: true },
  { id: 2, name: 'Wedding Details', isRequired: true },
  { id: 3, name: 'Vibe & Style', isRequired: true },
  { id: 4, name: 'Budget & Guests', isRequired: true },
  { id: 5, name: 'Contacts', isRequired: false },
];

export function useOnboardingOptimized(userId: string): UseOnboardingReturn {
  const router = useRouter();
  const { trackApiCall } = usePerformanceMonitor('Onboarding');
  const { optimizeImage } = useImageOptimization();
  const { weddingLocation } = useUserProfileDataOptimized();
  
  // State
  const [onboardingData, setOnboardingData] = useState<OnboardingData>(DEFAULT_ONBOARDING_DATA);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  // Memoized computed values
  const steps = useMemo(() => {
    return ONBOARDING_STEPS.map(step => ({
      ...step,
      isComplete: isStepComplete(step.id),
    }));
  }, [onboardingData]);

  const totalSteps = useMemo(() => ONBOARDING_STEPS.length, []);

  const progressPercentage = useMemo(() => {
    const completedSteps = steps.filter(step => step.isComplete).length;
    return Math.round((completedSteps / totalSteps) * 100);
  }, [steps, totalSteps]);

  // Memoized validation functions
  const validateStep = useCallback((stepId: number): boolean => {
    const startTime = performance.now();
    const newErrors: Record<string, string> = {};

    switch (stepId) {
      case 1: // Basic Info
        if (!onboardingData.userName.trim()) {
          newErrors.userName = 'User name is required';
        }
        if (!onboardingData.partnerName.trim()) {
          newErrors.partnerName = 'Partner name is required';
        }
        if (onboardingData.partnerEmail && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(onboardingData.partnerEmail)) {
          newErrors.partnerEmail = 'Please enter a valid email address';
        }
        break;

      case 2: // Wedding Details
        if (!onboardingData.weddingDate) {
          newErrors.weddingDate = 'Wedding date is required';
        } else {
          const selectedDate = new Date(onboardingData.weddingDate);
          const today = new Date();
          if (selectedDate <= today) {
            newErrors.weddingDate = 'Wedding date must be in the future';
          }
        }
        if (!onboardingData.weddingLocationUndecided && !onboardingData.weddingLocation.trim()) {
          newErrors.weddingLocation = 'Wedding location is required';
        }
        break;

      case 3: // Vibe & Style
        if (onboardingData.vibeInputMethod === 'pills' && onboardingData.vibe.length === 0) {
          newErrors.vibe = 'Please select at least one vibe';
        }
        if (onboardingData.vibeInputMethod === 'image' && !onboardingData.inspirationImage) {
          newErrors.inspirationImage = 'Please upload an inspiration image';
        }
        break;

      case 4: // Budget & Guests
        if (onboardingData.maxBudget < 1000) {
          newErrors.maxBudget = 'Budget must be at least $1,000';
        }
        if (onboardingData.maxBudget > 1000000) {
          newErrors.maxBudget = 'Budget cannot exceed $1,000,000';
        }
        if (onboardingData.guestCount < 1) {
          newErrors.guestCount = 'Guest count must be at least 1';
        }
        if (onboardingData.guestCount > 1000) {
          newErrors.guestCount = 'Guest count cannot exceed 1,000';
        }
        break;

      case 5: // Contacts (optional)
        // No validation required for optional step
        break;
    }

    setErrors(newErrors);
    const isValid = Object.keys(newErrors).length === 0;
    
    trackApiCall(`/api/validateOnboardingStep/${stepId}`, performance.now() - startTime, isValid);
    return isValid;
  }, [onboardingData, trackApiCall]);

  const isStepComplete = useCallback((stepId: number): boolean => {
    switch (stepId) {
      case 1:
        return !!(onboardingData.userName.trim() && onboardingData.partnerName.trim());
      case 2:
        return !!(onboardingData.weddingDate && (onboardingData.weddingLocationUndecided || onboardingData.weddingLocation.trim()));
      case 3:
        return onboardingData.vibeInputMethod === 'pills' ? onboardingData.vibe.length > 0 : onboardingData.generatedVibes.length > 0;
      case 4:
        return onboardingData.maxBudget >= 1000 && onboardingData.guestCount >= 1;
      case 5:
        return true; // Optional step
      default:
        return false;
    }
  }, [onboardingData]);

  const canProceedToNext = useCallback((stepId: number): boolean => {
    return isStepComplete(stepId) && validateStep(stepId);
  }, [isStepComplete, validateStep]);

  // Memoized actions
  const setCurrentStep = useCallback((step: number) => {
    setOnboardingData(prev => ({ ...prev, currentStep: step }));
  }, []);

  const updateField = useCallback((field: keyof OnboardingData, value: any) => {
    setOnboardingData(prev => ({ ...prev, [field]: value }));
  }, []);

  const updateContact = useCallback((contactId: string, updates: Partial<OnboardingContact>) => {
    setOnboardingData(prev => ({
      ...prev,
      contacts: prev.contacts.map(contact =>
        contact.id === contactId ? { ...contact, ...updates } : contact
      )
    }));
  }, []);

  const addContact = useCallback(() => {
    const newContact: OnboardingContact = {
      id: uuidv4(),
      name: '',
      email: null,
      phone: null,
      category: '',
      website: null,
      avatarColor: getRandomAvatarColor(),
      userId,
      orderIndex: onboardingData.contacts.length,
    };
    
    setOnboardingData(prev => ({
      ...prev,
      contacts: [...prev.contacts, newContact]
    }));
  }, [userId, onboardingData.contacts.length]);

  const removeContact = useCallback((contactId: string) => {
    setOnboardingData(prev => ({
      ...prev,
      contacts: prev.contacts.filter(contact => contact.id !== contactId)
    }));
  }, []);

  // Memoized form handlers
  const handleSaveStep = useCallback(async (stepData: Partial<OnboardingData>): Promise<boolean> => {
    const startTime = performance.now();
    setIsSaving(true);
    
    try {
      // Update local state
      setOnboardingData(prev => ({ ...prev, ...stepData }));
      
      // Save to Firestore
      const userRef = doc(db, 'users', userId);
      await updateDoc(userRef, {
        ...stepData,
        updatedAt: new Date().toISOString(),
      });
      
      trackApiCall('/api/saveOnboardingStep', performance.now() - startTime, true);
      return true;
    } catch (error) {
      console.error('Error saving onboarding step:', error);
      trackApiCall('/api/saveOnboardingStep', performance.now() - startTime, false);
      toast.error('Failed to save progress');
      return false;
    } finally {
      setIsSaving(false);
    }
  }, [userId, trackApiCall]);

  const handleNextStep = useCallback(async () => {
    if (!canProceedToNext(onboardingData.currentStep)) {
      return;
    }
    
    const success = await handleSaveStep({ currentStep: onboardingData.currentStep });
    if (success) {
      setCurrentStep(onboardingData.currentStep + 1);
    }
  }, [onboardingData.currentStep, canProceedToNext, handleSaveStep, setCurrentStep]);

  const handlePreviousStep = useCallback(() => {
    if (onboardingData.currentStep > 1) {
      setCurrentStep(onboardingData.currentStep - 1);
    }
  }, [onboardingData.currentStep, setCurrentStep]);

  const handleCompleteOnboarding = useCallback(async () => {
    const startTime = performance.now();
    setIsSaving(true);
    
    try {
      const completionData = {
        ...onboardingData,
        isOnboarded: true,
        onboardingCompletedAt: new Date().toISOString(),
      };
      
      const userRef = doc(db, 'users', userId);
      await updateDoc(userRef, completionData);
      
      trackApiCall('/api/completeOnboarding', performance.now() - startTime, true);
      toast.success("Welcome to Paige! Your wedding planning journey begins now.");
      
      // Redirect to dashboard
      setTimeout(() => {
        router.push("/");
      }, 1000);
    } catch (error) {
      console.error('Error completing onboarding:', error);
      trackApiCall('/api/completeOnboarding', performance.now() - startTime, false);
      toast.error('Failed to complete onboarding');
    } finally {
      setIsSaving(false);
    }
  }, [onboardingData, userId, trackApiCall, router]);

  const clearErrors = useCallback(() => {
    setErrors({});
  }, []);

  const resetOnboarding = useCallback(() => {
    setOnboardingData(DEFAULT_ONBOARDING_DATA);
    setErrors({});
    setIsSaving(false);
  }, []);

  // Load existing onboarding data
  useEffect(() => {
    const loadOnboardingData = async () => {
      const startTime = performance.now();
      setIsLoading(true);
      
      try {
        const userRef = doc(db, 'users', userId);
        const userDoc = await getDoc(userRef);
        
        if (userDoc.exists()) {
          const userData = userDoc.data();
          const existingData = {
            userName: userData.userName || '',
            partnerName: userData.partnerName || '',
            partnerEmail: userData.partnerEmail || '',
            plannerName: userData.plannerName || '',
            plannerEmail: userData.plannerEmail || '',
            weddingDate: userData.weddingDate || '',
            weddingLocation: userData.weddingLocation || '',
            weddingLocationUndecided: userData.weddingLocationUndecided || false,
            hasVenue: userData.hasVenue || null,
            selectedVenueMetadata: userData.selectedVenueMetadata || null,
            selectedPlannerMetadata: userData.selectedPlannerMetadata || null,
            vibe: userData.vibe || [],
            vibeInputMethod: userData.vibeInputMethod || 'pills',
            generatedVibes: userData.generatedVibes || [],
            inspirationImage: null, // File objects can't be stored in Firestore
            imagePreview: userData.imagePreview || null,
            pinterestLink: userData.pinterestLink || '',
            maxBudget: userData.maxBudget || 35000,
            guestCount: userData.guestCount || 100,
            contacts: userData.contacts || [],
            selectedCommunicationChannels: userData.selectedCommunicationChannels || [],
            currentStep: userData.currentStep || 1,
            isOnboarded: userData.isOnboarded || false,
            onboardingCompletedAt: userData.onboardingCompletedAt || null,
          };
          
          setOnboardingData(existingData);
        }
        
        trackApiCall('/api/loadOnboardingData', performance.now() - startTime, true);
      } catch (error) {
        console.error('Error loading onboarding data:', error);
        trackApiCall('/api/loadOnboardingData', performance.now() - startTime, false);
      } finally {
        setIsLoading(false);
      }
    };
    
    if (userId) {
      loadOnboardingData();
    }
  }, [userId, trackApiCall]);

  return {
    // State
    onboardingData,
    currentStep: onboardingData.currentStep,
    isLoading,
    isSaving,
    errors,
    
    // Computed values
    steps,
    isStepComplete,
    canProceedToNext,
    progressPercentage,
    totalSteps,
    
    // Actions
    setCurrentStep,
    updateField,
    updateContact,
    addContact,
    removeContact,
    
    // Form handlers
    handleNextStep,
    handlePreviousStep,
    handleSaveStep,
    handleCompleteOnboarding,
    
    // Utilities
    validateStep,
    clearErrors,
    resetOnboarding,
  };
}

// Utility function for random avatar colors
const getRandomAvatarColor = () => {
  const colors = [
    "#1565C0", "#2E7D32", "#6A1B9A", "#EF6C00", "#303F9F",
    "#00838F", "#AD1457", "#558B2F", "#4E342E", "#00695C"
  ];
  return colors[Math.floor(Math.random() * colors.length)];
}; 